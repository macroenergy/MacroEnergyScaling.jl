var documenterSearchIndex = {"docs":
[{"location":"scaling_settings/#Model-Scaling-Settings","page":"Scaling Settings","title":"Model Scaling Settings","text":"","category":"section"},{"location":"scaling_settings/","page":"Scaling Settings","title":"Scaling Settings","text":"Modules = [MacroEnergyScaling]\nPages = [\"scaling_settings.jl\"]","category":"page"},{"location":"scaling_settings/#MacroEnergyScaling.ScalingSettings","page":"Scaling Settings","title":"MacroEnergyScaling.ScalingSettings","text":"ScalingSettings\n\nA structure to store the scaling settings for the scaling algorithm. The fields are:\n\ncoeff_lb::Float64 = 1e-3: Lower bound for the scaling coefficients.\ncoeff_ub::Float64 = 1e6: Upper bound for the scaling coefficients.\nmin_coeff::Float64 = 1e-9: Minimum value for the scaling coefficients.\nrhs_lb::Float64 = 1e-3: Lower bound for the right-hand side scaling.\nrhs_ub::Float64 = 1e6: Upper bound for the right-hand side scaling.\nallow_recursion::Bool = true: Whether to allow recursion in the scaling algorithm.\ncount_actions::Bool = false: Whether to count the number of scaling actions.\nproxyvarratio_ub::Float64 = 10.0: Upper bound for the ratio of proxy variables to variables.\nproxyvarmap::Dict{VariableRef, Vector{Tuple{VariableRef, Float64}}} = Dict{VariableRef, Vector{Tuple{VariableRef, Float64}}}(): A dictionary mapping variables to a vector of tuples of variables and scaling coefficients.\n\n\n\n\n\n","category":"type"},{"location":"scaling_settings/#MacroEnergyScaling.get_scaling_settings-Tuple{Dict}","page":"Scaling Settings","title":"MacroEnergyScaling.get_scaling_settings","text":"get_scaling_settings(settings::Dict)::ScalingSettings\n\nExtracts the scaling settings from a dictionary and returns a ScalingSettings object.\n\n\n\n\n\n","category":"method"},{"location":"model_scaling/#Model-Scaling-Functions","page":"Model Scaling","title":"Model Scaling Functions","text":"","category":"section"},{"location":"model_scaling/","page":"Model Scaling","title":"Model Scaling","text":"Modules = [MacroEnergyScaling]\nPages = [\"model_scaling.jl\"]","category":"page"},{"location":"model_scaling/#MacroEnergyScaling.calc_coeff_multiplier-Tuple{Real, Real, Real}","page":"Model Scaling","title":"MacroEnergyScaling.calc_coeff_multiplier","text":"calc_coeff_multiplier(coeff::Real, coeff_lb::Real, coeff_ub::Real)\n\nCalculate the multiplier to scale the coefficient coeff to be within the bounds coeff_lb and coeff_ub.\n\n\n\n\n\n","category":"method"},{"location":"model_scaling/#MacroEnergyScaling.calc_rhs_multiplier-Tuple{JuMP.ConstraintRef, Vararg{Real, 4}}","page":"Model Scaling","title":"MacroEnergyScaling.calc_rhs_multiplier","text":"calc_rhs_multiplier(con_ref::ConstraintRef, rhs_lb::Real, rhs_ub::Real, coeff_lb::Real, coeff_ub::Real)\n\nCalculate the multiplier to scale the right-hand side of the constraint con_ref to be within the bounds rhs_lb and rhs_ub.\n\n\n\n\n\n","category":"method"},{"location":"model_scaling/#MacroEnergyScaling.existing_proxy_var-Tuple{JuMP.VariableRef, Real, Dict{JuMP.VariableRef, Vector{Tuple{JuMP.VariableRef, Float64}}}, Real}","page":"Model Scaling","title":"MacroEnergyScaling.existing_proxy_var","text":"existing_proxy_var(var::VariableRef, multiplier::Real, proxy_var_map::Dict{VariableRef, Vector{Tuple{VariableRef, Float64}}}, proxy_var_ratio_ub::Real)\n\nCheck if a proxy variable already exists for the variable var with a multiplier close to multiplier. If such a proxy variable exists, return it and its multiplier; otherwise, return nothing.\n\n\n\n\n\n","category":"method"},{"location":"model_scaling/#MacroEnergyScaling.get_proxy_var-Tuple{JuMP.VariableRef, Real, Dict{JuMP.VariableRef, Vector{Tuple{JuMP.VariableRef, Float64}}}, Real}","page":"Model Scaling","title":"MacroEnergyScaling.get_proxy_var","text":"get_proxy_var(var::VariableRef, multiplier::Real, proxy_var_map::Dict{VariableRef, Vector{Tuple{VariableRef, Float64}}}, proxy_var_ratio_ub::Real)\n\nCheck if a cached proxy variable exists for the variable var with a multiplier close to multiplier. If such a proxy variable exists, return it and its multiplier; otherwise, create a new proxy variable and return it.\n\n\n\n\n\n","category":"method"},{"location":"model_scaling/#MacroEnergyScaling.make_constraint","page":"Model Scaling","title":"MacroEnergyScaling.make_constraint","text":"make_constraint(EP::Model, var_coeff_pairs::AbstractDict{VariableRef, Float64}, rhs::MOI.AbstractScalarSet, con_name::AbstractString, rhs_multiplier::Real=1.0)\n\nCreate a new constraint with the given variable-coefficient pairs, right-hand side, and name; then add it to the model EP.\n\n\n\n\n\n","category":"function"},{"location":"model_scaling/#MacroEnergyScaling.make_proxy_var-Tuple{JuMP.VariableRef, Real}","page":"Model Scaling","title":"MacroEnergyScaling.make_proxy_var","text":"make_proxy_var(var::VariableRef, multiplier::Real)\n\nCreate a new proxy variable for the variable var with the given multiplier. The proxy and original variable are related by: var == proxy_var * multiplier.\n\n\n\n\n\n","category":"method"},{"location":"model_scaling/#MacroEnergyScaling.parse_constraint_name-Tuple{AbstractString}","page":"Model Scaling","title":"MacroEnergyScaling.parse_constraint_name","text":"parse_constraint_name(input::AbstractString)\n\nParse the name of a constraint and return the name and indexes as a tuple.\n\n\n\n\n\n","category":"method"},{"location":"model_scaling/#MacroEnergyScaling.prune_coefficients-Tuple{Real, Real, Real}","page":"Model Scaling","title":"MacroEnergyScaling.prune_coefficients","text":"prune_coefficients(new_coeff::Real, coeff::Real, multiplier::Real)\n\nIf a new coefficient is close to 1.0 or -1.0, return 1.0 or -1.0 respectively. \"close\" is defined using the Julia isapprox function.\n\n\n\n\n\n","category":"method"},{"location":"model_scaling/#MacroEnergyScaling.replace_constraint!","page":"Model Scaling","title":"MacroEnergyScaling.replace_constraint!","text":"replace_constraint!(con_ref::ConstraintRef, var_coeff_pairs=nothing, rhs_multiplier::Real=1.0)\n\nReplace the constraint con_ref with a new constraint with the given variable-coefficient pairs and right-hand side multiplier.\n\n\n\n\n\n","category":"function"},{"location":"model_scaling/#MacroEnergyScaling.scale_and_remake_constraint-Tuple{JuMP.ConstraintRef, MacroEnergyScaling.ScalingSettings}","page":"Model Scaling","title":"MacroEnergyScaling.scale_and_remake_constraint","text":"scale_and_remake_constraint(con_ref::ConstraintRef, scaling_settings::ScalingSettings)\n\nScale the coefficients and RHS of the constraint con_ref using the scaling settings scaling_settings.\n\nFirst we check if we can scale the right-hand side constant without creating proxy variables. Next, we iterate over the variable-coefficient pairs and scale them using proxy variables if necessary. The original constraint is then replaced with a new constraint using the scaled variable-coefficient pairs.\n\n\n\n\n\n","category":"method"},{"location":"model_scaling/#MacroEnergyScaling.scale_constraint!-Tuple{JuMP.ConstraintRef, MacroEnergyScaling.ScalingSettings}","page":"Model Scaling","title":"MacroEnergyScaling.scale_constraint!","text":"scale_constraint!(con_ref::ConstraintRef, scaling_settings::ScalingSettings)\n\nScale the coefficients and RHS of the constraint con_ref using the scaling settings scaling_settings. con_ref is a JuMP constraint reference.\n\n\n\n\n\n","category":"method"},{"location":"model_scaling/#MacroEnergyScaling.scale_constraints!","page":"Model Scaling","title":"MacroEnergyScaling.scale_constraints!","text":"scale_constraints!(constraint_list::Vector{ConstraintRef}, scaling_settings::ScalingSettings=ScalingSettings())\n\nScale the coefficients and RHS of all constraints in the model EP using the scaling settings scaling_settings. This function calls scaleconstraint!(conref, scalingsettings) on each constraint in `constraintlist`.\n\n\n\n\n\n","category":"function"},{"location":"model_scaling/#MacroEnergyScaling.scale_constraints!-2","page":"Model Scaling","title":"MacroEnergyScaling.scale_constraints!","text":"scale_constraints!(EP::Model, scaling_settings::ScalingSettings=ScalingSettings())\n\nScale the coefficients and RHS of all constraints in the model EP using the scaling settings scaling_settings. This function creates an array of all constraints in EP and then broadcasts scaleconstraint!(conref, scaling_settings) on the array.\n\n\n\n\n\n","category":"function"},{"location":"model_scaling/#MacroEnergyScaling.update_var_coeff_pair-Tuple{JuMP.VariableRef, Real, MacroEnergyScaling.ScalingSettings}","page":"Model Scaling","title":"MacroEnergyScaling.update_var_coeff_pair","text":"update_var_coeff_pair(var::VariableRef, coeff::Real, scaling_settings::ScalingSettings)\n\nUpdate the variable-coefficient pair (var, coeff) to be within the bounds specified in scaling_settings.\n\n\n\n\n\n","category":"method"},{"location":"#MacroEnergyScaling.jl","page":"Introduction","title":"MacroEnergyScaling.jl","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"A package to rescale and improve the numerical stability of JuMP-based optimization models","category":"page"},{"location":"#Instructions","page":"Introduction","title":"Instructions","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This package should work with any JuMP-based optimization model. To use it, simply add the package to your project and call the scale_constraints!(EP) function with your model EP. The package will automatically rescale the model and improve its numerical stability. The objective function is not rescaled.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The user can adjust the manner in which the model is rescaled by creating a ScalingSettings object and passing it to the scale_constraints!(EP, settings) function. The ScalingSettings object can be created by providing the preferred settings in a dictionary.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Some constraints will be rescaled using proxy variables, where a new variable will be created which is a multiple of the original variable. This will add additonal constraints to the model. In addition, some constraints will be deleted and recreated with the same name but re-scaled coefficients. This can change the order of the constraints in the model, potentially affecting the solution.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Note, this package does not reformulate the model, it only rescales it. Better performance and numerical stability can be achieved by reformulating the model. This can achieve the same re-scaled coefficients and right-hand sides but without the need for proxy variables and additional constraints.","category":"page"}]
}
